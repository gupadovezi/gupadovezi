# -*- coding: utf-8 -*-
"""quiz_sosort_correto

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1P0yF8a2smH1FaNuOM04gQL5FPwtutN2v
"""

import pygame
import random
import sys
import time
import math

# ---------- CONFIG ----------
WIDTH, HEIGHT = 800, 600
FPS = 60

BASE_TIME_PER_QUESTION = 12
TIME_DECREMENT_PER_LEVEL = 1
QUESTIONS_PER_LEVEL = 5

WHITE = (255, 255, 255)
BLACK = (10, 10, 10)
GREEN = (60, 180, 75)
RED = (220, 50, 50)
BLUE = (50, 120, 220)
YELLOW = (245, 200, 30)
GRAY = (200, 200, 200)

# ---------- QUESTIONS ----------
QUESTIONS = [
    {
        'question': 'Qual é a definição de escoliose idiopática segundo a diretriz SOSORT?',
        'choices': [
            'Curvatura lateral da coluna com rotação vertebral de causa desconhecida',
            'Curvatura causada por má postura ao sentar',
            'Curvatura lateral reversível após repouso',
            'Curvatura causada apenas por discrepância no comprimento das pernas'
        ],
        'answer': 0
    },
    {
        'question': 'Segundo a SOSORT, qual é o critério mínimo para diagnóstico radiográfico de escoliose?',
        'choices': [
            'Cobb ≥ 5° e rotação axial',
            'Cobb ≥ 10° e rotação axial',
            'Cobb ≥ 15° e rotação axial',
            'Cobb ≥ 20° e rotação axial'
        ],
        'answer': 1
    },
    {
        'question': 'Qual é a prevalência aproximada da escoliose idiopática adolescente (Cobb ≥10°) na população geral?',
        'choices': [
            '0,1 a 0,3%',
            '2 a 3%',
            '10 a 15%',
            '20%'
        ],
        'answer': 1
    },
    {
        'question': 'Segundo a diretriz, qual é o objetivo principal do tratamento com colete?',
        'choices': [
            'Corrigir completamente a curva em poucos meses',
            'Evitar progressão da curva até o fim do crescimento',
            'Aumentar a capacidade respiratória',
            'Substituir completamente a fisioterapia'
        ],
        'answer': 1
    },
    {
        'question': 'Quais métodos de exercício a SOSORT cita como específicos para escoliose (PSSE)?',
        'choices': [
            'Alongamentos gerais e corrida',
            'Métodos como SEAS, Schroth, Dobomed, etc.',
            'Exercícios apenas de musculação pesada',
            'Somente pilates'
        ],
        'answer': 1
    },
    {
        'question': 'Em curvas de 20° a 30° durante pico de crescimento, o risco de progressão é de aproximadamente:',
        'choices': [
            '5%',
            '20%',
            '60%',
            '90%'
        ],
        'answer': 2
    },
    {
        'question': 'Quando a cirurgia é geralmente considerada segundo a SOSORT?',
        'choices': [
            'Curvas acima de 50° em crescimento ou com impacto funcional/estético significativo',
            'Qualquer curva acima de 20°',
            'Somente após falha do colete e exercícios por mais de 10 anos',
            'Sempre que houver dor lombar'
        ],
        'answer': 0
    },
    {
        'question': 'Qual fator de adesão é fundamental para o sucesso do tratamento com colete?',
        'choices': [
            'Uso pelo menos 20 horas/dia conforme prescrição',
            'Usar apenas à noite',
            'Usar apenas quando sentir dor',
            'Alternar colete e cinta elástica'
        ],
        'answer': 0
    },
    {
        'question': 'Quais profissionais geralmente compõem a equipe multidisciplinar no tratamento conservador da escoliose?',
        'choices': [
            'Apenas ortopedista',
            'Médico, fisioterapeuta, técnico de colete, psicólogo quando necessário',
            'Somente personal trainer e nutricionista',
            'Apenas cirurgião e enfermeiro'
        ],
        'answer': 1
    },
    {
        'question': 'De acordo com a SOSORT, qual é um objetivo estético importante do tratamento conservador?',
        'choices': [
            'Diminuir a altura do tronco',
            'Melhorar a simetria postural e aparência do tronco',
            'Esconder a curva com roupas largas',
            'Evitar esportes coletivos'
        ],
        'answer': 1
    },
    {
        'question': 'Qual tipo de escoliose é causada por fatores externos e tende a regredir com tratamento da causa?',
        'choices': [
            'Idiopática',
            'Funcional',
            'Congênita',
            'Neuromuscular'
        ],
        'answer': 1
    },
    {
        'question': 'O teste clínico de Adams é utilizado para:',
        'choices': [
            'Avaliar flexibilidade do quadril',
            'Detectar gibosidade torácica e assimetria',
            'Medir força muscular',
            'Avaliar equilíbrio em pé'
        ],
        'answer': 1
    },
    {
        'question': 'Quais atividades esportivas a SOSORT considera geralmente seguras e recomendadas para pacientes com escoliose?',
        'choices': [
            'Nenhuma atividade física é segura',
            'Esportes gerais recreativos sem sobrecarga assimétrica extrema',
            'Somente natação competitiva',
            'Apenas caminhada leve'
        ],
        'answer': 1
    },
    {
        'question': 'Segundo a diretriz, a avaliação periódica deve incluir:',
        'choices': [
            'Somente radiografia anual',
            'Avaliação clínica, medidas de rotação, radiografia quando indicado',
            'Somente questionário de dor',
            'Apenas testes respiratórios'
        ],
        'answer': 1
    }
]

random.shuffle(QUESTIONS)

# ---------- PYGAME SETUP ----------
pygame.init()
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Jogo Educativo SOSORT")
clock = pygame.time.Clock()

FONT_BIG = pygame.font.SysFont("arial", 28)  # menor para caber mais linhas
FONT_MED = pygame.font.SysFont("arial", 22)
FONT_SMALL = pygame.font.SysFont("arial", 18)

# ---------- Mascote ----------
class Mascot:
    def __init__(self):
        self.x = 100
        self.y = HEIGHT - 120
        self.radius = 30
        self.vx = 120
        self.vy = 0
        self.gravity = 500
        self.jump_strength = -300
        self.on_ground = True
        self.color_phase = 0

    def update(self, dt, speed_multiplier=1.0):
        self.x += self.vx * dt * speed_multiplier
        if self.x - self.radius < 0 or self.x + self.radius > WIDTH:
            self.vx *= -1
        if not self.on_ground:
            self.vy += self.gravity * dt
            self.y += self.vy * dt
            if self.y >= HEIGHT - 120:
                self.y = HEIGHT - 120
                self.vy = 0
                self.on_ground = True
        self.color_phase += dt * 3
        if self.color_phase > 10:
            self.color_phase = 0

    def jump(self):
        if self.on_ground:
            self.vy = self.jump_strength
            self.on_ground = False

    def draw(self, surf):
        t = (1 + math.sin(self.color_phase)) / 2
        r = int(BLUE[0] * (1 - t) + YELLOW[0] * t)
        g = int(BLUE[1] * (1 - t) + YELLOW[1] * t)
        b = int(BLUE[2] * (1 - t) + YELLOW[2] * t)
        pygame.draw.circle(surf, (r, g, b), (int(self.x), int(self.y)), self.radius)
        pygame.draw.circle(surf, BLACK, (int(self.x - self.radius // 3), int(self.y - 6)), 4)
        pygame.draw.circle(surf, BLACK, (int(self.x + self.radius // 4), int(self.y - 6)), 4)

# ---------- GameState ----------
class GameState:
    def __init__(self):
        self.reset()

    def reset(self):
        self.score = 0
        self.question_index = 0
        self.level = 1
        self.time_per_question = BASE_TIME_PER_QUESTION
        self.current_start_time = time.time()
        self.selected = None
        self.feedback = None
        self.mascot = Mascot()
        self.running = True

    def current_question(self):
        if self.question_index < len(QUESTIONS):
            return QUESTIONS[self.question_index]
        return None

# ---------- Funções UI ----------
def draw_text_center(surf, text, font, color, x, y):
    r = font.render(text, True, color)
    rect = r.get_rect(center=(x, y))
    surf.blit(r, rect)

def draw_wrapped_text(surf, text, font, color, x, y, max_width):
    words = text.split(' ')
    lines = []
    current_line = ""
    for word in words:
        test_line = current_line + word + " "
        if font.size(test_line)[0] <= max_width:
            current_line = test_line
        else:
            lines.append(current_line.strip())
            current_line = word + " "
    if current_line:
        lines.append(current_line.strip())

    for i, line in enumerate(lines):
        line_surface = font.render(line, True, color)
        surf.blit(line_surface, (x, y + i * (font.get_height() + 2)))

def draw_question_ui(surf, gs):
    q = gs.current_question()
    if not q:
        return
    pygame.draw.rect(surf, GRAY, (40, 40, WIDTH - 80, 160), border_radius=8)
    draw_text_center(surf, f"Nível {gs.level}  —  Pontos: {gs.score}", FONT_SMALL, BLACK, WIDTH - 140, 60)

    # Quebra automática para perguntas
    draw_wrapped_text(surf, q['question'], FONT_BIG, BLACK, 60, 70, WIDTH - 120)

    start_y = 220
    btn_h = 60
    gap = 16
    for i, choice in enumerate(q['choices']):
        rect = pygame.Rect(60, start_y + i * (btn_h + gap), WIDTH - 120, btn_h)
        color = WHITE
        if gs.selected == i:
            color = (220, 220, 255)
        pygame.draw.rect(surf, color, rect, border_radius=6)
        pygame.draw.rect(surf, BLACK, rect, 2, border_radius=6)

        # Quebra automática para alternativas
        draw_wrapped_text(surf, f"{chr(65 + i)}. {choice}", FONT_MED, BLACK, rect.x + 12, rect.y + 8, rect.width - 24)

    elapsed = time.time() - gs.current_start_time
    tleft = max(0, gs.time_per_question - elapsed)
    bar_w = WIDTH - 120
    bar_h = 14
    bar_x = 60
    bar_y = HEIGHT - 70
    pygame.draw.rect(surf, (220,220,220), (bar_x, bar_y, bar_w, bar_h), border_radius=6)
    fill_w = int(bar_w * (tleft / gs.time_per_question))
    fill_color = GREEN if tleft > gs.time_per_question * 0.4 else RED
    pygame.draw.rect(surf, fill_color, (bar_x, bar_y, fill_w, bar_h), border_radius=6)
    time_txt = FONT_SMALL.render(f"Tempo restante: {int(tleft)}s", True, BLACK)
    surf.blit(time_txt, (bar_x, bar_y - 22))

    if gs.feedback:
        f_text, f_time = gs.feedback
        if time.time() - f_time < 1.4:
            color = GREEN if f_text == 'correct' else RED
            draw_text_center(surf, "✔ Correto!" if f_text == 'correct' else "✖ Errado!", FONT_BIG, color, WIDTH//2, HEIGHT - 140)

def next_question(gs, correct=False):
    if correct:
        gs.score += 10 * gs.level
    else:
        gs.score = max(0, gs.score - 2)
    gs.question_index += 1
    if gs.question_index % QUESTIONS_PER_LEVEL == 0:
        gs.level += 1
        gs.time_per_question = max(3, BASE_TIME_PER_QUESTION - (gs.level - 1) * TIME_DECREMENT_PER_LEVEL)
    gs.selected = None
    gs.current_start_time = time.time()
    if correct:
        gs.mascot.jump()
    if gs.question_index >= len(QUESTIONS):
        gs.running = False

def handle_click(gs, pos):
    start_y = 220
    btn_h = 60
    gap = 16
    for i in range(4):
        rect = pygame.Rect(60, start_y + i * (btn_h + gap), WIDTH - 120, btn_h)
        if rect.collidepoint(pos):
            gs.selected = i
            q = gs.current_question()
            if q:
                if i == q['answer']:
                    gs.feedback = ('correct', time.time())
                    next_question(gs, correct=True)
                else:
                    gs.feedback = ('wrong', time.time())
                    next_question(gs, correct=False)

def main_loop():
    game = GameState()
    while True:
        dt = clock.tick(FPS) / 1000.0
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN:
                if game.running:
                    handle_click(game, event.pos)
                else:
                    game.reset()
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE:
                    game.mascot.jump()
                if game.running and event.key in (pygame.K_a, pygame.K_b, pygame.K_c, pygame.K_d):
                    idx = {pygame.K_a:0, pygame.K_b:1, pygame.K_c:2, pygame.K_d:3}[event.key]
                    game.selected = idx
                    q = game.current_question()
                    if q:
                        if idx == q['answer']:
                            game.feedback = ('correct', time.time())
                            next_question(game, correct=True)
                        else:
                            game.feedback = ('wrong', time.time())
                            next_question(game, correct=False)

        speed_mul = 1 + (game.level - 1) * 0.08
        game.mascot.update(dt, speed_multiplier=speed_mul)

        if game.running:
            elapsed = time.time() - game.current_start_time
            if elapsed >= game.time_per_question:
                game.feedback = ('wrong', time.time())
                next_question(game, correct=False)

        screen.fill((240, 245, 250))
        if game.running:
            game.mascot.draw(screen)
            draw_question_ui(screen, game)
        else:
            draw_text_center(screen, "Fim de Jogo!", FONT_BIG, BLACK, WIDTH//2, HEIGHT//2 - 60)
            draw_text_center(screen, f"Pontos: {game.score}", FONT_MED, BLUE, WIDTH//2, HEIGHT//2)
            draw_text_center(screen, "Clique para jogar novamente", FONT_SMALL, BLACK, WIDTH//2, HEIGHT//2 + 60)
            pygame.draw.circle(screen, YELLOW, (WIDTH//2, HEIGHT//2 + 140), 40)
            pygame.draw.circle(screen, BLACK, (WIDTH//2 - 10, HEIGHT//2 + 135), 4)
            pygame.draw.circle(screen, BLACK, (WIDTH//2 + 10, HEIGHT//2 + 135), 4)

        pygame.display.flip()

if __name__ == "__main__":
    main_loop()